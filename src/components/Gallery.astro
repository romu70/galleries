---
import { getCollection } from "astro:content";
import Item from '../components/Item.astro';
// import Thumbnail from '../components/Thumbnail.astro';
// import Detail from '../components/Detail.astro';
import { Debug } from 'astro:components';

const allFonts = await getCollection("fonts");

// Most recent font first
function compare(a, b) {
  if(a["slug"] > b["slug"]) {
    return -1;
  }
  if(a["slug"] < b["slug"]) {
    return 1;
  }
  if(a["slug"] == b["slug"]) {
    return 0;
  }
}
---

<div class="items-grid" id="items-grid">
  <!-- <Detail /> -->
  {
    allFonts.sort(compare).map((font, index) => (
      // <Debug {font} />
      <Item font={font} index={index}/>
    ))
  }
</div>

<script>
  type Divs = NodeListOf<HTMLElement> | null | undefined;
  type Div = HTMLElement | null | undefined;
  let grid: Element | null = null;
  let thumbnails: Divs = null;
  let details: Divs = null;
  let currentShownDetail: Div = null;
  let detailPaneHeight: number = 0;
  let currentThumbnailHeight: number = 0;
  let rem: number = 0;
  let mobileViewBreakpoint: number =  0;


  // Init
  document.addEventListener('DOMContentLoaded', function () {
    grid = document.querySelector("#items-grid");
    thumbnails = grid?.querySelectorAll('.thumbnail');
    details = grid?.querySelectorAll('.detail');
    hideAllDetails();
    addThumbnailImageClick();
    addKeyboardManagement();
    addDetailClick('.close-button', onDetailCloseClick);
    addDetailClick('.next-button', onDetailNextClick);
    addDetailClick('.previous-button', onDetailPreviousClick);
    detailPaneHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--detail-pane-height'));
    rem = parseInt(getComputedStyle(document.documentElement).fontSize);
    mobileViewBreakpoint =  parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-view-breakpoint'));
  });

  function addThumbnailImageClick() {
    thumbnails?.forEach(thumbnail => {
      thumbnail.children[0].addEventListener('click', onThumbnailImageClick);
    });
  }

  function addKeyboardManagement() {  
    document.addEventListener("keyup", (event) => {
      // console.log(`Key "${event.key}" released [event: keyup]`);
      // console.log(event);
      console.log("current index: " + currentShownDetail);
      if (event.defaultPrevented) {
        return; // Do nothing if the event was already processed
      };

      switch (event.key) {
        case "ArrowDown":
          // Open the currectly selected thumbnail if any
          break;
        case "ArrowUp":
          // Close the currectly selected thumbnail if any
          break;
        case "ArrowLeft":
          // Previous thumbnail
          break;
        case "ArrowRight":
          // Next thumbnail
          break;
        case "Enter":
          // Open the currectly selected thumbnail if any
          break;
        case " ":
          // Open or close the currectly selected thumbnail if any
          break;
        case "Escape":
          // Close the currectly selected thumbnail if any
          break;
        default:
          return; // Quit when this doesn't handle the key event.
      };

      // Cancel the default action to avoid it being handled twice
      event.preventDefault();
    });
  }

  function addDetailClick(clazz, callback) {
    let buttons = grid?.querySelectorAll(clazz);
    buttons?.forEach(button => {
      button.addEventListener('click', callback);
    });
  }
  
  function hideAllDetails() {
    details?.forEach(detail => {
      detail.style.visibility = "collapse";
    });
  }

  function hideDetail(detail: Div) {
    if(detail != null) {
      detail.style.visibility = "collapse";
      currentShownDetail = null;
      let thumbnail: Div = grid?.querySelector(`.thumbnail[data-index="${detail.dataset.index}"]`);
      markThumbnailInactive(thumbnail);
    }
  }

  function showDetail(detail: Div) {
    if(detail != null) {

      // Respect the media query. If width < 768, the detail is full screen,
      // if not, it's below the thumbnail
      if(window.innerWidth < mobileViewBreakpoint) {
        // Mobile view
        detail.style.top = "0";
        detail.style.height = "100vh";
      } else {
        // Wide view
        
        // Place the detail pane just below the thumbnail's line
        let thumbnail: Div = grid?.querySelector(`.thumbnail[data-index="${detail.dataset.index}"]`);
        markThumbnailActive(thumbnail);
        let top = thumbnail?.getBoundingClientRect()["bottom"] + window.scrollY;

        detail.style.top = top?.toString() + "px"
        // Set the selected item height to "insert" the detail pane into the grid layout
        let height = thumbnail?.offsetHeight / rem + detailPaneHeight;
        if(thumbnail && thumbnail.parentElement) {
          thumbnail.parentElement.style.height = height + "rem";
        }

        // The idea of the timeout is taken from this:
        // https://stackoverflow.com/questions/71181018/scrollintoview-doesnt-scroll-anywhere
        setTimeout(function () {
          thumbnail?.scrollIntoView({
               behavior: "smooth",
               block: "center",
           });
      }, 100);
      }

      detail.style.visibility = "visible";
      currentShownDetail = detail;

      // If the image placeholder ratio is > image ratio, so it's width first,
      // else it's height first
      let placeholder: Div = detail.firstElementChild;
      let divRatio: number = Number(placeholder?.offsetWidth) / Number(placeholder?.offsetHeight);
      let detailImg: Div = grid?.querySelector(`.detail-left img[data-index="${detail.dataset.index}"]`);
      let imgRatio: number = Number(detailImg?.getAttribute("width")) / Number(detailImg?.getAttribute("height"));
      console.log("divRatio: " + divRatio);
      console.log("imgRatio: " + imgRatio);

      if(detailImg) {
        if (divRatio < imgRatio) {
          console.log("less");
          detailImg.style.width = "100%";
          detailImg.style.height = "auto";
        } else {
          console.log("more");
          detailImg.style.width = "auto";
          detailImg.style.height = "100%";
        }
      }
    }
  }

  function onThumbnailImageClick(e) {
    processImage(e.target.parentNode.dataset.index);
  }

  function processImage(index: number) {
    // Get the clicked detail element
    let detail: Div = grid?.querySelector(`.detail[data-index="${index}"]`);

    // If the already open item is clicked,
    // then it's closed
    if(currentShownDetail == detail) {
      hideDetail(currentShownDetail);
    }
    else {
      // If another item is clicked,
      // we close the already open one and then
      // we open the new one
      hideDetail(currentShownDetail);
      showDetail(detail);

      // Set active the previous button if the index is > 0
      if(index > 0) {
        let button = grid?.querySelector(`.detail[data-index="${index}"] .previous-button`);
        button?.removeAttribute("disabled");
      }

      // Set active the next button if the index is > 0
      if(thumbnails && index == (thumbnails?.length - 1)) {
        let button = grid?.querySelector(`.detail[data-index="${index}"] .next-button`);
        button?.setAttribute("disabled", "");
      }
    }
  }

  function markThumbnailActive(thumbnail: Div) {
    thumbnail?.classList.add("active");
    // Save the thumbnail height
    if(thumbnail) {
      currentThumbnailHeight = thumbnail.offsetHeight;
    }
  }

  function markThumbnailInactive(thumbnail: Div) {
    thumbnail?.classList.remove("active");
    // Restore the thumbnail height
    if(thumbnail) {
      thumbnail.style.height = currentThumbnailHeight.toString() + "px";
      // Also restore the height of the Item div to remove empty space
      if(thumbnail.parentElement) {
        thumbnail.parentElement.style.height = currentThumbnailHeight.toString() + "px";
      }
    }
  }

  function onDetailCloseClick(e) {
    hideDetail(e.target.parentNode.parentNode);
  }

  function onDetailNextClick(e) {
    let idx = +e.target.dataset.index + 1;
    processImage(idx)
  }

  function onDetailPreviousClick(e) {
    let idx = +e.target.dataset.index - 1;
    processImage(idx)
  }
</script>

<style>

  .items-grid {
    display: grid;
    grid-template-columns: repeat(1, 1fr);
    padding: 1em;
    width: 100vw;
    row-gap: 1rem;
  }

  @media (min-width: 360px) {
	.items-grid {
		grid-template-columns: repeat(1, 1fr);
	}

  @media (min-width: 440px) {
	.items-grid {
		grid-template-columns: repeat(2, 1fr);
	}

  @media (min-width: 768px) {
	.items-grid {
		grid-template-columns: repeat(3, 1fr);
    margin-bottom: 8rem;
	}

  @media (min-width: 1024px) {
    .items-grid {
      grid-template-columns: repeat(4, 1fr);
    }
  }

  @media (min-width: 1280px) {
    .items-grid {
      grid-template-columns: repeat(5, 1fr);
    }
  }

  /* Ensure the last line is correctly  aligned
    by adding an empty element with the same width as other images.
  */
  /* .items-grid::after {
    content: "";
    flex-grow: 999;
  } */
</style>
  