---
import { getCollection } from "astro:content";
import Item from '../components/Item.astro';
// import Thumbnail from '../components/Thumbnail.astro';
// import Detail from '../components/Detail.astro';
import { Debug } from 'astro:components';

const allFonts = await getCollection("fonts");
---

<div class="items-grid" id="items-grid">
  <!-- <Detail /> -->
  {
    allFonts.map((font, index) => (
      // <Debug {font} />
      <Item font={font} index={index}/>
    ))
  }
</div>

<script>
  type Divs = NodeListOf<HTMLElement> | null | undefined;
  type Div = HTMLElement | null | undefined;
  let grid: Element | null = null;
  let thumbnails: Divs = null;
  let details: Divs = null;
  let currentShownDetail: Div = null;
  let detailPaneHeight: number = 0;
  let currentThumbnailHeight: number = 0;
  let rem: number = 0;
  let mobileViewBreakpoint: number =  0;


  // Init
  document.addEventListener('DOMContentLoaded', function () {
    grid = document.querySelector("#items-grid");
    thumbnails = grid?.querySelectorAll('.thumbnail');
    details = grid?.querySelectorAll('.detail');
    hideAllDetails();
    addThumbnailImageClick();
    addKeyboardManagement();
    addDetailClick('.close-button', onDetailCloseClick);
    addDetailClick('.next-button', onDetailNextClick);
    addDetailClick('.previous-button', onDetailPreviousClick);
    detailPaneHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--detail-pane-height'));
    rem = parseInt(getComputedStyle(document.documentElement).fontSize);
    mobileViewBreakpoint =  parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-view-breakpoint'));
  });

  function addThumbnailImageClick() {
    thumbnails?.forEach(thumbnail => {
      thumbnail.children[0].addEventListener('click', onThumbnailImageClick);
    });
  }

  function addKeyboardManagement() {  
    document.addEventListener("keyup", (event) => {
      console.log(`Key "${event.key}" released [event: keyup]`);
      console.log(event);
      console.log("current index: " + currentShownDetail);
      if (event.defaultPrevented) {
        return; // Do nothing if the event was already processed
      };

      switch (event.key) {
        case "ArrowDown":
          // Do something for "down arrow" key press.
          break;
        case "ArrowUp":
          // Do something for "up arrow" key press.
          break;
        case "ArrowLeft":
          // Do something for "left arrow" key press.
          break;
        case "ArrowRight":
          // Do something for "right arrow" key press.
          break;
        case "Enter":
          // Do something for "enter" or "return" key press.
          break;
        case " ":
          // Do something for "space" key press.
          break;
        case "Escape":
          // Do something for "esc" key press.
          break;
        default:
          return; // Quit when this doesn't handle the key event.
      };

      // Cancel the default action to avoid it being handled twice
      event.preventDefault();
    });
  }

  function addDetailClick(clazz, callback) {
    let buttons = grid?.querySelectorAll(clazz);
    buttons?.forEach(button => {
      button.addEventListener('click', callback);
    });
  }
  
  function hideAllDetails() {
    details?.forEach(detail => {
      detail.style.visibility = "collapse";
    });
  }

  function hideDetail(detail: Div) {
    if(detail != null) {
      detail.style.visibility = "collapse";
      currentShownDetail = null;
      let thumbnail: Div = grid?.querySelector(`.thumbnail[data-index="${detail.dataset.index}"]`);
      markThumbnailInactive(thumbnail);
    }
  }

  function showDetail(detail: Div) {
    if(detail != null) {

      // Respect the media query. If width < 768, the detail is full screen,
      // if not, it's below the thumbnail
      if(window.innerWidth < mobileViewBreakpoint) {
        // Mobile view
        detail.style.top = "0";
      } else {
        // Wide view
        
        // Place the detail pane just below the thumbnail's line
        let thumbnail: Div = grid?.querySelector(`.thumbnail[data-index="${detail.dataset.index}"]`);
        markThumbnailActive(thumbnail);
        let top = thumbnail?.getBoundingClientRect()["bottom"] + window.scrollY;

        detail.style.top = top?.toString() + "px"
        // Set the selected item height to "insert" the detail pane into the grid layout
        let height = thumbnail?.offsetHeight / rem + detailPaneHeight;
        console.log("new thumb height" + thumbnail?.offsetHeight);
        if(thumbnail && thumbnail.parentElement) {
          thumbnail.parentElement.style.height = height + "rem";
        }
      }

      detail.style.visibility = "visible";
      currentShownDetail = detail;

      // If the image placeholder ratio is > image ratio, so it's width first,
      // else it's height first
      let placeholder: Div = detail.firstElementChild;
      let divRatio: number = Number(placeholder?.offsetWidth) / Number(placeholder?.offsetHeight);
      let detailImg: Div = grid?.querySelector(`.detail-left img[data-index="${detail.dataset.index}"]`);
      let imgRatio: number = Number(detailImg?.getAttribute("width")) / Number(detailImg?.getAttribute("height"));

      if(detailImg) {
        if (divRatio < imgRatio) {
          detailImg.style.width = "100%";
          detailImg.style.height = "auto";
        } else {
          detailImg.style.width = "auto";
          detailImg.style.height = "100%";
        }
      }
    }
  }

  function onThumbnailImageClick(e) {
    processImage(e.target.parentNode.dataset.index);
  }

  function processImage(index: number) {
    // Get the clicked detail element
    let detail: Div = grid?.querySelector(`.detail[data-index="${index}"]`);

    // If the already open item is clicked,
    // then it's closed
    if(currentShownDetail == detail) {
      hideDetail(currentShownDetail);
    }
    else {
      // If another item is clicked,
      // we close the already open one and then
      // we open the new one
      hideDetail(currentShownDetail);
      showDetail(detail);

      // Set active the previous button if the index is > 0
      if(index > 0) {
        let button = grid?.querySelector(`.detail[data-index="${index}"] .previous-button`);
        button?.removeAttribute("disabled");
      }

      // Set active the next button if the index is > 0
      if(thumbnails && index == (thumbnails?.length - 1)) {
        let button = grid?.querySelector(`.detail[data-index="${index}"] .next-button`);
        button?.setAttribute("disabled", "");
      }
    }
  }

  function markThumbnailActive(thumbnail: Div) {
    thumbnail?.classList.add("active");
    // Save the thumbnail height
    if(thumbnail) {
      currentThumbnailHeight = thumbnail.offsetHeight;
      console.log("save thumb height: " + currentThumbnailHeight);
    }
  }

  function markThumbnailInactive(thumbnail: Div) {
    thumbnail?.classList.remove("active");
    // Restore the thumbnail height
    if(thumbnail) {
      console.log("restore thumb height: " + currentThumbnailHeight);
      thumbnail.style.height = currentThumbnailHeight.toString() + "px";
      if(thumbnail.parentElement) {
        thumbnail.parentElement.style.height = currentThumbnailHeight.toString() + "px";
      }
    }
  }

  function onDetailCloseClick(e) {
    hideDetail(e.target.parentNode.parentNode);
  }

  function onDetailNextClick(e) {
    let idx = +e.target.dataset.index + 1;
    processImage(idx)
  }

  function onDetailPreviousClick(e) {
    let idx = +e.target.dataset.index - 1;
    processImage(idx)
  }

  function onKeyUp(e) {
    console.log(e);
  }

  // function callback(e) {

  //   const { key, shiftKey, target } = e;
  //   const action = target.getAttribute("data-action");
  //   const index = +target.parentNode.getAttribute("data-index");
  //   // console.log(target);
  //   // console.log(action);

  //   ////// Keyboard management ///////
  //   if (key !== "Tab" && !shiftKey) {
  //     // open the pane (or close if clicking the thumb)
  //     if (!key && action === "open") {
  //       if (index === currentImage && detailPaneOpen)
  //         closeDetailPane();
  //       else
  //         openDetailPane(index);

  //     // close the pane
  //     } else if (key === "Escape" || action === "close") {
  //       closeDetailPane();

  //     // previous image
  //     } else if (key === "ArrowLeft" || (!key && action === "prev")) {
  //       prev();

  //     // next image
  //     } else if (key === "ArrowRight" || (!key && action === "next")) {
  //       next();
  //     }

  //     updateView();
  //     moveFocus(target, action);
  //   }
  // }

  // function moveFocus(target, action) {
  //   if(action === "prev" || action === "next") {
  //     if (target.disabled) {
  //       const btn = action + "-btn";
  //       document.getElementById(btn)?.focus();
  //     } else {
  //       target.focus();
  //     }
  //   }
  // }

</script>

<style>

  .items-grid {
    display: grid;
    grid-template-columns: repeat(1, 1fr);
    padding: 1em;
    width: 100vw;
    row-gap: 1rem;
  }

  @media (min-width: 360px) {
	.items-grid {
		grid-template-columns: repeat(2, 1fr);
	}

  @media (min-width: 768px) {
	.items-grid {
		grid-template-columns: repeat(3, 1fr);
	}

  @media (min-width: 1024px) {
    .items-grid {
      grid-template-columns: repeat(4, 1fr);
    }
  }

  @media (min-width: 1280px) {
    .items-grid {
      grid-template-columns: repeat(5, 1fr);
    }
  }

  /* Ensure the last line is correctly  aligned
    by adding an empty element with the same width as other images.
  */
  /* .items-grid::after {
    content: "";
    flex-grow: 999;
  } */
</style>
  